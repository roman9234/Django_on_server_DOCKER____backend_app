---- Варианты поставки проекта ----

pip package - можно в виде пакета создать целое приложение или программк

.deb package - дистрибутив linux. Позволяет разворачивать проекты

.rpm package - для других систем которые его использут

архив с файлами прокта - можно положить интрукции к установке туда

ссылка на проект в GitHub - не самый удобный вариант для полноценного проекта

Docker image - позволяет запустить почти любое приложение на почти любой ОС на почти любом железе
Система должна поддерживать контейнеризацию
+быстрая доставка приложений
+стандартизация - на любой системе команды почти одинаковые
+эффективное перемещение - при замене сервера или обновлении просто перенести проект
+безопаность(изоляция) - проект находится в изолированной среде и из него нет доступа к основному компьютеру
+экономия - можно запустить множество контейнеров на одном железе

---- Контейнер это ----
Контейнер это пакет, содержащий всё необходимое для запуска приложений
код приложения / бинарник
зависимости
системные инструменты
интерпретатор
ОС (в большинстве случаев есть, в очень урезанном виде для экономии)

Применение:
- в разработке и тестировании - тестируем в среде схожей с продом в рамках своей машины
- разворачивание приложения на сервере - в контейнере
- микромервисные системы - используют образы и контейнеры схожие с Docker. Kubernetes

---- Определения ----

Docker — это открытая платформа для разработки, доставки и эксплуатации приложений.

Docker Compose — это средство для определения и запуска приложений Docker с несколькими контейнерами.

Dockerfile — исходный файл с инструкциями, на основе которого собирается докер-образ.

Docker Image — докер-образ из которого запускается контейнер.


---- Теория ----


Для удобной и повторяемой сборки проекта на Django необходимо создать Docker-образ
и подготовить Docker-Compose конфигурацию.

Docker-образ позволяет упаковать все зависимости проекта и настройки окружения в одно место,
что упрощает его развертывание на различных средах.

Docker-Compose конфигурация позволяет описать инфраструктуру проекта, включая базу данных,
сервер приложений и другие сервисы, и управлять ими с помощью одной команды.
Это значительно упрощает установку и настройку проекта
и позволяет избежать конфликтов и ошибок при развертывании.

Docker на Mac и Windows Docker использует под собой виртуальную машину, не используя все ресурсы
В Linux - нативно используемая контейнеризация

---- Образы с Dokerfile ----

//Список образов:
docker image ls
//Удалить образ
docker image rm



---- Образы docker-compose.yml ----

//Запуск сборки (если в docker-compose.yml указан раздел build и откуда его запускать)
docker compose build

//Запуск этого контейнера
docker compose up -d
-d значит что запуск в режиме демона - фоновом режиме

//Запуск контйнера из нового билда
docker compose up -d --build


//список контейнеров
docker compose ps

//остановка всех сервисов
docker compose down



---- Контейнеры ----

//Создание образа - точка показывает что мы собирам тот Dockerfile который находится в техущем каталоге
docker build .
//Сделать образ с тэгом
docker build --tag django_app_image .





//Список контейнеров
docker ps
//Удалить контейнер
docker rm

//запуск из образа (django_app_image) с удалением после остановки (--rm) и заданным именем (--name django_container):
docker run --rm --name django_container django_app_image
//Запуск контейнера с портами для подключения (внешний:внутренний)
docker run --rm --name django_container -p "8000:8000" django_app_image

---- Сборка образа и проекта ----
//Версия Docker
docker -v

---- Подготовка Dockerfile
Создаём Docker образ:
добавляем файл Dockerfile

----Сделать сборку:
устанавливаем Docker Desktop, cоздаём прокт, применяем миграции

Из-за особенностей изоляции Docker мы не можем полчить доступ к контейнеру по http://127.0.0.1:8000/
Чтобы получить доступ нужно добавить в Dockerfile параметр чтобы запуск приложения произошёл не на интерфейсе localhost
а на всех интерфейсах 0.0.0.0:8000

Для доступа к порту 8000 с основного компьютера нужно указать порт к которому мы хотим иметь доступ
к какому порту подключаемся на нашем компе : какой это порт в контейнере
docker run --rm --name django_container -p "8000:8000" django_app_image
Теперь у нас есть доступ к приложению через http://127.0.0.1:8000/

То что сейчас есть, не буедт сохранять данные в БД между запусками контейнеров






